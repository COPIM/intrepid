import csv

from django.http import Http404, HttpResponse
from django.shortcuts import render

from cms import models as cms_models
from initiatives import models


def index(request):
    """
    Site index for intrepid.
    :param request: a request
    :return: a response
    """

    # Generate an initiative if one does not exist.
    if models.Initiative.objects.all().count() == 0:
        initiative, c = models.Initiative.objects.get_or_create(
            name="Test Initiative",
            defaults={
                "description": "This is a test initiative autogenerated by the "
                "system",
                "active": True,
            },
        )
    else:
        initiative = None

    news_items = cms_models.SiteWideNewsItem.objects.all().order_by("order")[
        0:4
    ]

    quotes = cms_models.HomePageQuote.objects.all().order_by("order")[0:4]

    context = {
        "initiative": initiative,
        "news_items": news_items,
        "quotes": quotes,
    }
    template = "base/frontend/index.html"
    return render(request, template, context)


# TODO: Deprecate this function:


def test_index(request):
    """
    An early and now unused test index loader
    :param request: a request
    :return: a response
    """
    template_name = request.GET.get("template", "index.html")
    template = "base/frontend/{}".format(template_name)
    context = {}
    return render(
        request,
        template,
        context,
    )


def who_we_are(request):
    """
    Render the "who we are" page
    :param request: the request object
    :return: a response
    """
    template_name = "whoweare.html"
    stewards = cms_models.WhoWeAreProfileItem.objects.filter(
        section="stewards"
    ).order_by("order")
    members = cms_models.WhoWeAreProfileItem.objects.filter(
        section="members"
    ).order_by("order")
    managers = cms_models.WhoWeAreProfileItem.objects.filter(
        section="managers"
    ).order_by("order")
    secretariat = cms_models.WhoWeAreProfileItem.objects.filter(
        section="secretariat"
    ).order_by("order")
    print(secretariat)
    template = "base/frontend/{}".format(template_name)
    context = {
        "stewards": stewards,
        "members": members,
        "managers": managers,
        "secretariat": secretariat,
    }
    return render(
        request,
        template,
        context,
    )


def create_csv(request, queryset, field_list_method=None, field_method=None):
    """
    Create a CSV output
    :param field_list_method: a method that lists the fields to evaluate
    :param request: request object
    :param queryset: the queryset
    :param field_method: a method that builds a field list
    :return: a response object
    """
    # set up the response to download
    response = HttpResponse(content_type="text/csv")
    response["Content-Disposition"] = "attachment;filename=export.csv"

    # dynamically gather the fields and write a header
    writer = csv.writer(response)

    fields_raw = [field.name for field in queryset.model._meta.fields]
    fields_custom = []

    if field_method:
        fields_custom.extend(field_list_method(queryset))
        writer.writerow(fields_raw + fields_custom)
    else:
        writer.writerow(fields_raw)

    # write the data
    for row in queryset:
        row_to_write = [getattr(row, field) for field in fields_raw]

        if field_method:
            row_to_write.extend(
                [getattr(row, field_method)(field) for field in fields_custom]
            )

        writer.writerow(row_to_write)

    return response


def _signups_field_list(signups):
    """
    Get the field list for signups
    :param signups: a list of signups
    :return: a list of fields
    """
    field_list = set()

    for signup in signups:
        field_list.update(signup.stored_fields)

    return field_list


def export(request, target):
    """
    Export a CSV of signups
    :param request: a request
    :param target: the object type to export
    :return: a response
    """
    if target == "signups":
        # we can use the middleware stored version to avoid a DB call here
        if len(request.signups) == 0:
            raise Http404
        else:
            return create_csv(
                request,
                request.signups,
                field_list_method=_signups_field_list,
                field_method="stored_answer",
            )
    else:
        raise Http404
